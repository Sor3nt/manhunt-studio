import NBinary from "./NBinary.js";
import Event from "./Event.js";
import Status from "./Status.js";
import Loader from "./Plugin/Loader.js";
import Config from "./Config.js";
import Games from "./Plugin/Games.js";
import Game from "./Plugin/Game.js";

export default class FileDrop{

    /**
     *
     * @type {{name: string, binary: NBinary, fileNamePath: string}[]}
     */
    files = [];

    /**
     *
     * @type {Result[]}
     */
    entries = [];

    openRequests = 0;



    constructor(id){
        let _this = this;
        let dropZone = document.getElementById(id);

        dropZone.addEventListener('dragover', function(e) {
            e.stopPropagation();
            e.preventDefault();
            e.dataTransfer.dropEffect = 'copy';
        });

        dropZone.addEventListener('drop', function (e) {
            _this.onDrop(e);
        });
    }

    async getFile(fileEntry) {
        try {
            return await new Promise((resolve, reject) => fileEntry.file(resolve, reject));
        } catch (err) {
            console.log(err);
        }
    }


    async scanFiles(item) {

        let _this = this;

        if (item.isDirectory) {
            let directoryReader = item.createReader();

            directoryReader.readEntries(function(entries) {
                entries.forEach(function(entry) {
                    _this.scanFiles(entry );
                });
            });
        }else{

            let extension = item.name.split(".");
            if (extension.length === 1)
                return; //no extension

            extension = extension[extension.length - 1].toLowerCase();

            //only process known file extensions and ignore export folder generated by MHT
            if (Config.fileFormats.indexOf(extension) === -1 || item.fullPath.indexOf("#") !== -1 || item.fullPath.indexOf("export") !== -1 )
                return;


            this.openRequests++;
            this.processFile(await this.getFile(item), item.fullPath)

        }
    }

    onDrop(e){
        // Prevent default behavior (Prevent file from being opened)
        e.preventDefault();

        Status.hideWelcome();
        Status.show("Importing...");


        let items = e.dataTransfer.items;
        for (let i=0; i<items.length; i++) {
            let item = items[i].webkitGetAsEntry();

            if (item) {
                this.scanFiles(item);
            }
        }
    }

    /**
     *
     * @param file {Blob}
     * @param fileNamePath
     */
    processFile(file, fileNamePath){

        let _this = this;
        let reader = new FileReader();

        /**
         * @param event {Event}
         */
        reader.onload = function(event) {

            Status.show(`${fileNamePath} loaded`);

            let binary = new NBinary(event.target.result);
            _this.files.push({
                name: file.name,
                fileNamePath: fileNamePath,
                binary: binary
            });

            _this.openRequests--;
            if (_this.openRequests === 0)
                _this.allFilesLoaded();

        };

        reader.readAsArrayBuffer(file);

    }

    allFilesLoaded(){
        let _this = this;

        this.files.forEach(function (file) {

            file.binary.setCurrent(0);

            try{

                let parsed = Loader.parse(file.binary, {fileNamePath: file.fileNamePath});
                Status.show(`${file.fileNamePath} parsed`);

                parsed.forEach(function (entry) {
                    entry.setFilePath(file.fileNamePath);
                    _this.entries.push(entry);
                });

                Event.dispatch(Event.DROP_FILE, file);

            }catch(error){
                console.error("Error parsing file",file.fileNamePath,"Exception", error);
            }
        });

        this.finish();
    }

    reset(){
        this.entries = [];
        this.files = [];
    }

    /**
     *
     * @returns {{game: string, version: double, platform: string}}
     */
    guessGamePlatformVersion(){

        let info = {
            game: null,
            platform: null,
            version: null
        };

        this.files.forEach(function (file) {
            if (info.platform === null){
                //scene1_pc.bsp, scene1_pc.tex, picload_pc.tex, mat_pc.bin...
                if (file.fileNamePath.indexOf('_pc') !== -1)
                    info.platform = Games.PLATFORM.PC;
            }

            if (info.game === null){

                if (file.fileNamePath.indexOf('_pc.txd') !== -1)
                    info.game = Games.GAMES.MANHUNT;

                if (file.fileNamePath.indexOf('_pc.tex') !== -1)
                    info.game = Games.GAMES.MANHUNT_2;
            }

        });

        if (info.game === null || info.platform === null){

            this.entries.forEach(function (entry) {

                if (info.game === null){
                    if (entry.gameFourCC !== null)
                        info.game = entry.gameFourCC;
                }

            });

        }

        return info;
    }

    finish(){

        let ressourceInfo = this.guessGamePlatformVersion();

        let game = new Game(ressourceInfo.game, ressourceInfo.platform, ressourceInfo.version);
        Games.addGame(game);

        this.entries.forEach(function (entry) {

            game.addToStorage(entry);

            Event.dispatch(Event.ENTRY_LOADED, {
                entry: entry
            });

        });

        Status.hide();

        this.reset();
    }
}
